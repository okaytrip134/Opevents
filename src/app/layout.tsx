// app/layout.tsx
import type { Metadata } from "next";
import { ReactNode } from "react";
import "./globals.css";
import Navbar from "@/component/Navbar";
import LenisProvider from "@/component/LenisProvider";

export const metadata: Metadata = {
  title: "Eventer",
  description: "Generated by create next app",
};


export default function RootLayout({ children }: { children: ReactNode }) {
  const cleanScript = `
    (function () {
      try {
        const attrsToRemove = ['cz-shortcut-listen', 'data-gramm', 'data-gramm_id', 'data-gramm_editor', 'data-gramm_checked'];
        function removeAttrs(root) {
          if (!root) return;
          // Remove from root (body or html)
          attrsToRemove.forEach(a => {
            if (root.hasAttribute && root.hasAttribute(a)) root.removeAttribute(a);
          });
        }
        removeAttrs(document.documentElement);
        removeAttrs(document.body);
        // also remove from any elements that may have them already
        attrsToRemove.forEach(attr => {
          const nodes = document.querySelectorAll('[' + attr + ']');
          nodes.forEach(n => n.removeAttribute(attr));
        });
        // Watch and remove if re-injected before hydration finishes
        const observer = new MutationObserver((mutations) => {
          for (let m of mutations) {
            if (m.type === 'attributes') {
              const target = m.target;
              attrsToRemove.forEach(a => {
                if (target && (target.hasAttribute && target.hasAttribute(a))) {
                  try { target.removeAttribute(a); } catch(e) {}
                }
              });
            } else if (m.type === 'childList') {
              m.addedNodes.forEach(node => {
                if (node && node.querySelectorAll) {
                  attrsToRemove.forEach(attr => {
                    node.querySelectorAll('[' + attr + ']').forEach(n => n.removeAttribute(attr));
                  });
                }
              });
            }
          }
        });
        observer.observe(document, { attributes: true, subtree: true, childList: true });
        // Stop observing after a short while (hydration typically finishes quickly)
        setTimeout(() => observer.disconnect(), 5000);
      } catch (e) { /* fail silently */ }
    })();
  `;

  return (
    <html lang="en">
      <body>
        {/* Inline script runs immediately (before hydration), removes injected attributes */}
        <script id="hydration-fix" dangerouslySetInnerHTML={{ __html: cleanScript }} />
        <LenisProvider> {/* for smooth scrolling */}
          <Navbar />
          {children}
        </LenisProvider>
      </body>
    </html>
  );
}
